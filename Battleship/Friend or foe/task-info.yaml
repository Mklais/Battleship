type: edu
files:
- name: src/battleship/Main.java
  visible: true
  text: |
    package battleship;

    public class Main {

        public static void main(String[] args) {
            // Write your code here
        }
    }
  learner_created: false
- name: test/Tests.java
  visible: false
  text: |-
    import org.hyperskill.hstest.dynamic.input.DynamicTestingMethod;
    import org.hyperskill.hstest.exception.outcomes.WrongAnswer;
    import org.hyperskill.hstest.stage.StageTest;
    import org.hyperskill.hstest.testcase.CheckResult;
    import org.hyperskill.hstest.testing.TestedProgram;


    public class Tests extends StageTest<String> {
        @DynamicTestingMethod
        CheckResult testExample() {

            TestedProgram main = new TestedProgram();
            String output = main.start().trim();
            String[][] matrix;

            if (!matrixIsEmpty(getFieldMatrix(output))) {
                return CheckResult.wrong("Not an empty game field at the start of the game");
            }

            // Filling the first player field
            if (!output.toLowerCase().contains("aircraft carrier")) {
                return CheckResult.wrong("After starting the program, you should request " +
                    "the coordinates of the Aircraft Carrier in that way:\n" +
                    "\"Enter the coordinates of the Aircraft Carrier (5 cells):\"");
            }

            output = main.execute("F3 F7").trim();
            matrix = getFieldMatrix(output);
            findShipByCoordinates(matrix, "F3 F7");

            if (!output.toLowerCase().contains("battleship")) {
                return CheckResult.wrong("After asking for the Aircraft Carrier coordinates, you should request " +
                    "the coordinates of the Battleship in that way:\n" +
                    "\"Enter the coordinates of the Battleship (4 cells):\"");
            }

            output = main.execute("A1 D1").trim();
            matrix = getFieldMatrix(output);
            findShipByCoordinates(matrix, "A1 D1");

            if (!output.toLowerCase().contains("submarine")) {
                return CheckResult.wrong("After asking for the Battleship coordinates, you should request " +
                    "the coordinates of the Submarine in that way:\n" +
                    "\"Enter the coordinates of the Submarine (3 cells):\"");
            }

            output = main.execute("J7 J10").trim();
            if (isGameFieldPrinted(output)) {
                return CheckResult.wrong("Your program should not print a game field if there is an input mistake.");
            }

            output = main.execute("J10 J8").trim();
            matrix = getFieldMatrix(output);
            findShipByCoordinates(matrix, "J10 J8");

            if (!output.toLowerCase().contains("cruiser")) {
                return CheckResult.wrong("After asking for the Submarine coordinates, you should request " +
                    "the coordinates of the Cruiser in that way:\n" +
                    "\"Enter the coordinates of the Cruiser (3 cells):\"");
            }

            output = main.execute("B9 D8").trim();
            if (isGameFieldPrinted(output)) {
                return CheckResult.wrong("Your program should not print a game field if there is an input mistake.");
            }

            output = main.execute("B9 D9").trim();
            matrix = getFieldMatrix(output);
            findShipByCoordinates(matrix, "B9 D9");

            if (!output.toLowerCase().contains("destroyer")) {
                return CheckResult.wrong("After asking for the Cruiser coordinates, you should request " +
                    "the coordinates of the Destroyer in that way:\n" +
                    "\"Enter the coordinates of the Destroyer (2 cells):\"");
            }

            output = main.execute("E6 D6").trim();
            if (isGameFieldPrinted(output)) {
                return CheckResult.wrong("Your program should not print a game field if there is an input mistake. " +
                    "(Too close to another ship)");
            }

            output = main.execute("I2 J2").trim();
            matrix = getFieldMatrix(output);
            findShipByCoordinates(matrix, "I2 J2");

            if (!output.toLowerCase().contains("enter")) {
                return CheckResult.wrong("No offer found to give the move to another player");
            }

            output = main.execute("");

            // Filling the second player field

            if (!output.toLowerCase().contains("aircraft carrier")) {
                return CheckResult.wrong("After filling the first player field, you should request the second player's " +
                    "coordinates of the Aircraft Carrier in that way:\n" +
                    "\"Enter the coordinates of the Aircraft Carrier (5 cells):\"");
            }

            output = main.execute("H2 H6");
            matrix = getFieldMatrix(output);
            findShipByCoordinates(matrix, "H2 H6");

            if (!output.toLowerCase().contains("battleship")) {
                return CheckResult.wrong("After asking for the Aircraft Carrier coordinates, you should request " +
                    "the coordinates of the Battleship in that way:\n" +
                    "\"Enter the coordinates of the Battleship (4 cells):\"");
            }

            output = main.execute("F3 F6");
            matrix = getFieldMatrix(output);
            findShipByCoordinates(matrix, "F3 F6");

            if (!output.toLowerCase().contains("submarine")) {
                return CheckResult.wrong("After asking for the Battleship coordinates, you should request " +
                    "the coordinates of the Submarine in that way:\n" +
                    "\"Enter the coordinates of the Submarine (3 cells):\"");
            }

            output = main.execute("H8 F8").trim();
            matrix = getFieldMatrix(output);
            findShipByCoordinates(matrix, "H8 F8");

            if (!output.toLowerCase().contains("cruiser")) {
                return CheckResult.wrong("After asking for the Submarine coordinates, you should request " +
                    "the coordinates of the Cruiser in that way:\n" +
                    "\"Enter the coordinates of the Cruiser (3 cells):\"");
            }

            output = main.execute("D4 D6").trim();
            matrix = getFieldMatrix(output);
            findShipByCoordinates(matrix, "D4 D6");

            if (!output.toLowerCase().contains("destroyer")) {
                return CheckResult.wrong("After asking for the Cruiser coordinates, you should request " +
                    "the coordinates of the Destroyer in that way:\n" +
                    "\"Enter the coordinates of the Destroyer (2 cells):\"");
            }

            output = main.execute("D8 C8");
            matrix = getFieldMatrix(output);
            findShipByCoordinates(matrix, "D8 C8");

            if (!output.toLowerCase().contains("enter")) {
                return CheckResult.wrong("no offer found to give the move to another player");
            }
            output = main.execute("");

            // Players' moves
            String[] splittedOutput = output.split("---\n");
            if (splittedOutput.length != 2) {
                return CheckResult.wrong("An incorrect number of game fields.\nThere is should 2 fields separated by \"---------------------\"");
            }
            if (!matrixIsEmpty(getFieldMatrix(splittedOutput[0]))) {
                return CheckResult.wrong("At the start of the game the upper field should be empty");
            }
            findAllShips(getFieldMatrix(splittedOutput[1]),
                new String[]{"F3 F7", "A1 D1", "J10 J8", "B9 D9", "I2 J2"});

            output = main.execute("I3");
            if (!output.toLowerCase().contains("missed")) {
                return CheckResult.wrong("Incorrect reaction of the program if the player missed");
            }

            output = main.execute("");
            checkMissing(getFieldMatrix(output), "I3");

            splittedOutput = output.split("---\n");
            if (splittedOutput.length != 2) {
                return CheckResult.wrong("An incorrect number of game fields (2 should be)");
            }
            if (!matrixIsEmpty(getFieldMatrix(splittedOutput[0]))) {
                return CheckResult.wrong("At the start of the game the upper field should be empty");
            }
            findAllShips(getFieldMatrix(splittedOutput[1]),
                new String[]{"H2 H6", "F3 F6", "H8 F8", "D4 D6", "D8 C8"});

            output = main.execute("C9");
            if (!output.toLowerCase().contains("hit")) {
                return CheckResult.wrong("Incorrect reaction of the program if the player hit the ship");
            }
            main.execute("");

            makeMoveTillTheEnd(main);

            return CheckResult.correct();
        }

        void makeMoveTillTheEnd(TestedProgram main) {

            String[] secondPlayerMoves = {"A1", "B1", "C1", "D1", "B9", "C9", "D9", "F3", "F4", "F5", "F6", "F7", "I2", "J2", "J8", "J9", "J10"};
            String[] firstPlayerMoves = {"D4", "D5", "D6", "C8", "D8", "F3", "F4", "F5", "F6", "F7", "D10", "E10", "F10", "G10", "J1", "J2", "J3"};

            String[][] matrix;
            String output;
            int i;

            for (i = 0; i < 3; i++) {
                main.execute(firstPlayerMoves[i]);
                main.execute("");
                main.execute(secondPlayerMoves[i]);
                main.execute("");
            }

            main.execute(firstPlayerMoves[i]);
            main.execute("");

            output = main.execute(secondPlayerMoves[i]);
            if (!output.contains("sank")) {
                throw new WrongAnswer("After a ship was sunk you should print \"You sank a ship!\" and ask to press Enter.");
            }
            output = main.execute("");

            String[] splittedOutput = output.split("---\n");
            if (splittedOutput.length != 2) {
                throw new WrongAnswer("An incorrect number of game fields.\nThere is should 2 fields separated by \"---------------------\"");
            }

            matrix = getFieldMatrix(splittedOutput[1]);
            checkShot(matrix, "A1");
            checkShot(matrix, "B1");
            checkShot(matrix, "C1");
            checkShot(matrix, "D1");

            for (i = i + 1; i < secondPlayerMoves.length - 1; i++) {
                main.execute(firstPlayerMoves[i]);
                main.execute("");
                main.execute(secondPlayerMoves[i]);
                main.execute("");
            }

            main.execute(firstPlayerMoves[i]);
            main.execute("");
            output = main.execute(secondPlayerMoves[i]).toLowerCase();

            if (!output.contains("won") || !output.contains("congratulations")) {
                throw new WrongAnswer("If a player has sunk all enemy ships you should print:\n" +
                    "\"You sank the last ship. You won. Congratulations!\"");
            }
        }

        void findShipByCoordinates(String[][] matrix, String coordinates) {
            int[] coordinatesInt = parseCoordinates(coordinates);

            if (coordinatesInt[0] > coordinatesInt[2]) {
                int swap = coordinatesInt[0];
                coordinatesInt[0] = coordinatesInt[2];
                coordinatesInt[2] = swap;
            } else if (coordinatesInt[1] > coordinatesInt[3]) {
                int swap = coordinatesInt[1];
                coordinatesInt[1] = coordinatesInt[3];
                coordinatesInt[3] = swap;
            }

            if (coordinatesInt[0] == coordinatesInt[2]) {
                int cord = coordinatesInt[0];
                for (int i = coordinatesInt[1]; i <= coordinatesInt[3]; i++) {
                    if (!matrix[cord][i].toLowerCase().equals("x") && !matrix[cord][i].toLowerCase().equals("o")) {
                        throw new WrongAnswer("The ship's cells were not found at the coordinates \"" + coordinates + "\"");
                    }
                }
            } else {
                int cord = coordinatesInt[1];
                for (int i = coordinatesInt[0]; i <= coordinatesInt[2]; i++) {
                    if (!matrix[i][cord].toLowerCase().equals("x") && !matrix[i][cord].toLowerCase().equals("o")) {
                        throw new WrongAnswer("The ship's cells were not found at the \"" + coordinates + "\"");
                    }
                }
            }
        }

        boolean matrixIsEmpty(String[][] matrix) {
            for (String[] strings : matrix) {
                for (int j = 0; j < matrix.length; j++) {
                    if (!strings[j].trim().equals("~")) {
                        return false;
                    }
                }
            }
            return true;
        }

        void checkShot(String[][] matrix, String coordinate) {
            int[] parsedCoordinate = new int[2];
            parsedCoordinate[0] = charToInt(coordinate.toLowerCase().substring(0, 1));
            parsedCoordinate[1] = Integer.parseInt(coordinate.substring(1)) - 1;

            if (!matrix[parsedCoordinate[0]][parsedCoordinate[1]].toLowerCase().contains("x")) {
                throw new WrongAnswer("Expected hit in \"" + coordinate + "\".");
            }
        }

        boolean checkMissing(String[][] matrix, String coordinate) {
            int[] parsedCoordinate = new int[2];
            parsedCoordinate[0] = charToInt(coordinate.toLowerCase().substring(0, 1));
            parsedCoordinate[1] = Integer.parseInt(coordinate.substring(1)) - 1;

            return matrix[parsedCoordinate[0]][parsedCoordinate[1]].toLowerCase().contains("m");
        }

        int[] parseCoordinates(String coordinatesString) {
            String[] splittedCoords = coordinatesString.split(" ");
            int[] parsedCoordinates = new int[4];

            parsedCoordinates[0] = charToInt(splittedCoords[0].substring(0, 1));
            parsedCoordinates[1] = Integer.parseInt(splittedCoords[0].substring(1)) - 1;
            parsedCoordinates[2] = charToInt(splittedCoords[1].substring(0, 1));
            parsedCoordinates[3] = Integer.parseInt(splittedCoords[1].substring(1)) - 1;

            return parsedCoordinates;
        }

        int charToInt(String charCoordinate) {
            charCoordinate = charCoordinate.toLowerCase();
            char character = charCoordinate.charAt(0);
            return (int) character - (int) 'a';
        }

        String[][] getFieldMatrix(String output) {

            WrongAnswer cantParseException = new WrongAnswer("Can't parse the game field\n" +
                "Make sure you print it like in examples!");

            String[] splittedOutput = output.split("\n");
            String[][] matrix = new String[10][10];

            try {
                int index = 0;
                while (!(splittedOutput[index].contains("1") &&
                    splittedOutput[index].contains("2") &&
                    splittedOutput[index].contains("10"))) {
                    index++;
                    if (index > 1000) {
                        throw cantParseException;
                    }
                }
                index++;

                for (int i = 0; i < 10; i++) {
                    String temp = splittedOutput[index].substring(2).trim();
                    String[] splittedLine = temp.trim().split(" ");
                    if (splittedLine.length != 10) {
                        throw cantParseException;
                    }
                    matrix[i] = splittedLine;
                    index++;
                }
            } catch (IndexOutOfBoundsException ignored) {
                throw cantParseException;
            }

            return matrix;
        }

        boolean isGameFieldPrinted(String output) {
            return output.contains("1") && output.contains("2") && output.contains("10");
        }

        void findAllShips(String[][] matrix, String[] coordinates) {
            for (String item : coordinates) {
                findShipByCoordinates(matrix, item);
            }
        }
    }
  learner_created: false
- name: src/battleship/UserActionValidation.java
  visible: true
  text: |
    package battleship;

    public class UserActionValidation {
        public void shipPlacementValidation(ShipPlacement shipData, Game game, CreateField fieldCreation) {
            //TODO: SET A ERROR MESSAGE AND NOT DISPLAY IT IN ALL METHODS


            // Setting the user input as valid before going to check them
            game.setValiduserInput(true);

            if (!inputCoordinatesFormatValidation(game) ||
                    !inputCoordinatesRangeValidation(game) ||
                    !shipLength(shipData, game) ||
                    !diagonalCoordinatesValidation(game) ||
                    !adjacentToShipValidation(game, fieldCreation)) {
                game.setValiduserInput(false);
            }
        }
        public boolean userShootCoordinatesValidation(Game game) {
            // Setting the user input as valid before going to check them
            game.setValiduserInput(true);

            if (!userShootCoordinatesRangeValidation(game)) {
                game.setValiduserInput(false);
                return false;
            } else {
                return true;
            }
        }
        private boolean userShootCoordinatesRangeValidation(Game game) {
            // Checking if the shot is in valid range <= 10
            if (game.getShootRow() <= 10 && game.getShootCol() <= 10) {
                return true;
            } else {
                System.out.println();
                System.out.println("Error! You entered the wrong coordinates! Try again:");
                return false;
            }
        }
        private boolean inputCoordinatesFormatValidation(Game game) {
            for (String coordinate : game.getUserCoordinates()) {
                try {
                    char firstLetter = coordinate.charAt(0);
                    int col = Character.toUpperCase(firstLetter - 'A');

                    int row = Integer.parseInt(coordinate.substring(1)) - 1;

                    // If the coordinate is valid, continue with the next coordinate
                } catch (Exception e) {
                    // If an exception occurs, handle the invalid coordinate and set the flag to false
                    System.out.println();
                    System.out.println("Error! Invalid coordinate format: " + coordinate);
                    return false; // Exit the method with false if any coordinate is invalid
                }
            }

            return true;
        }
        private boolean inputCoordinatesRangeValidation(Game game) {
            for (String coordinate : game.getUserCoordinates()) {
                try {
                    char firstLetter = coordinate.charAt(0);
                    int col = Character.toUpperCase(firstLetter) - 'A';

                    if (!(col >= 0 && col <= 10)) {
                        System.out.println();
                        System.out.println("Error! Invalid column coordinate: " + firstLetter);
                        return false; // Return false when an invalid coordinate is found
                    }

                    int row = Integer.parseInt(coordinate.substring(1)) - 1;

                    if (!(row >= 0 && row <= 10)) {
                        System.out.println();
                        System.out.println("Error! Invalid row coordinate: " + coordinate.substring(1));
                        return false; // Return false when an invalid coordinate is found
                    }

                    // If the coordinate is valid, continue with the next coordinate
                } catch (Exception e) {
                    // If an exception occurs, handle the invalid coordinate and set the flag to false
                    System.out.println();
                    System.out.println("Error! Invalid coordinate format: " + coordinate);
                    return false; // Return false when an invalid coordinate format is found
                }
            }

            return true; // Return true if all coordinates are valid
        }
        private boolean shipLength(ShipPlacement shipData, Game game) {
            int shipLength = shipData.getCellSize();

            if (game.getUserRow1() == game.getUserRow2()) {
                // If both the row letters are the same, we check for columns
                int userInputShipLength = Math.abs(game.getUserCol2() - game.getUserCol1()) + 1;
                if (userInputShipLength == shipLength) {
                    return true;
                } else {
                    System.out.println();
                    String message = "Error! Wrong length of the " + shipData.getShipName() + "! Try again:";
                    System.out.println(message);
                    return false;
                }
            } else {
                // Else we check for rows
                int userInputShipLength = game.getUserRow2() - game.getUserRow1() + 1;
                if (userInputShipLength == shipLength) {
                    return true;
                } else {
                    System.out.println();
                    String message = "Error! Wrong length of the " + shipData.getShipName() + "! Try again:";
                    System.out.println(message);
                    return false;
                }
            }
        }
        private boolean diagonalCoordinatesValidation(Game game) {
            if (game.getUserRow1() == game.getUserRow2() || game.getUserCol1() == game.getUserCol2()) {
                return true;
            } else {
                System.out.println();
                String message = "Error! Wrong ship location! Try again:";
                System.out.println(message);
                return false;
            }
        }
        private boolean adjacentToShipValidation(Game game, CreateField fieldCreation) {
            int row1 = game.getUserRow1();
            int row2 = game.getUserRow2();
            int col1 = game.getUserCol1();
            int col2 = game.getUserCol2();


            // Iterate through the cells around the ship's location
            for (int row = row1 - 1; row <= row2 + 1; row++) {
                for (int col = col1 - 1; col <= col2 + 1; col++) {
                    // Check if the current cell is within the bounds of the field
                    if (row >= 0 && row < fieldCreation.getField().length && col >= 0 && col < fieldCreation.getField()[row].length) {
                        // Check if the current cell contains a ship tile
                        if (fieldCreation.getField()[row][col].equals(fieldCreation.getShipTile())) {
                            System.out.println();
                            String message = "Error! You placed it too close to another one. Try again:";
                            System.out.println(message);
                            System.out.println();
                            return false; // Ship is adjacent to another ship, return false
                        }
                    }
                }
            }

            return true; // No adjacent ships found, return true
        }
        private boolean shipLengthValidation(ShipPlacement shipData, Game game) {
            int firstCord = Integer.parseInt(game.getUserCoordinates()[0].substring(1));
            int secondCord = Integer.parseInt(game.getUserCoordinates()[1].substring(1));

            char firstLetter = game.getUserCoordinates()[0].charAt(0);
            char secondLetter = game.getUserCoordinates()[1].charAt(0);

            if (firstLetter == secondLetter) {
                int rowResult = Math.abs(firstCord - secondCord) + 1;

                if (rowResult == shipData.getCellSize()) {
                    return true;
                } else {
                    String message = "Error! Wrong length of the " + shipData.getShipName() + "! Try again:";
                    System.out.println(message);
                    return false;
                }
            } else {
                int colResult = Math.abs(firstLetter - secondLetter) + 1;

                if (colResult == shipData.getCellSize()) {
                    return true;
                } else {
                    String message = "Error! Wrong length of the " + shipData.getShipName() + "! Try again:";
                    System.out.println(message);
                    return false;
                }
            }
        }
    }
  learner_created: true
- name: src/battleship/UserInterface.java
  visible: true
  text: |
    package battleship;

    public class UserInterface {
        public void headSpace() {
            System.out.println();
        }
        public void startGame() {
            System.out.println();
            System.out.println("The game starts!");
        }

        public void shoot() {
            System.out.println();
            System.out.println("Take a shot!");
        }
        public void endGame() {
            System.out.println();
            System.out.println("You sank the last ship. You won. Congratulations!");
        }
        public void sankShip() {
            System.out.println();
            System.out.println("You sank a ship! Specify a new target:");
        }
        public void hitShip() {
            System.out.println();
            System.out.println("You hit a ship! Try again:");
        }
        public void missShip() {
            System.out.println();
            System.out.println("You missed. Try again:");
        }
    }
  learner_created: true
- name: src/battleship/CreateField.java
  visible: true
  text: |
    package battleship;

    import java.util.Scanner;

    public class CreateField {
        private final String emptyFieldTile = " ~";
        private final String spaceFieldTile = " ";
        private final String shipTile = " O";
        private final String hitTile = " X";
        private final String missTile = " M";
        private final int fieldColumn = 11;
        private final int fieldRow = 11;
        private String[][] field;
        private String[][] fogOfWarField;
        UserActionValidation userActionValidation = new UserActionValidation();
        public String[][] getField() {
            return field;
        }
        public void setField(String[][] field) {
            this.field = field;
        }
        public String getShipTile() {
            return shipTile;
        }
        public String[][] getFogOfWarField() {
            return fogOfWarField;
        }
        public void setFogOfWarField(String[][] fogOfWarField) {
            this.fogOfWarField = fogOfWarField;
        }

        public void createfield() {
            // Creating an empty field
            // Initialize the field array
            field = new String[fieldRow][fieldColumn];
            int colNumber = 1;
            char rowChar = 'A';

            for (int row = 0; row < fieldRow; row++) {
                for (int col = 0; col < fieldColumn; col++) {
                    if (row == 0 && col == 0) {
                        field[row][col] = spaceFieldTile;
                    } else if (row == 0 && col >= 1) {
                        field[row][col] = spaceFieldTile + colNumber;
                        colNumber++;
                    } else if (row > 0 && col == 0) {
                        field[row][col] = String.valueOf(rowChar);
                        rowChar++;
                    } else {
                        field[row][col] = emptyFieldTile;
                    }
                }
            }
            // Setting created EMPTY field
            setField(field);
        }
        public void printField() {
            for (int row = 0; row < field.length; row++) {
                for (int col = 0; col < field[row].length; col++) {
                    System.out.print(field[row][col]);
                }
                System.out.println();
            }
        }
        public void createFogOfWar() {
            // Creating an empty field
            // Initialize the field array
            fogOfWarField = new String[fieldRow][fieldColumn];
            int colNumber = 1;
            char rowChar = 'A';

            for (int row = 0; row < fieldRow; row++) {
                for (int col = 0; col < fieldColumn; col++) {
                    if (row == 0 && col == 0) {
                        fogOfWarField[row][col] = spaceFieldTile;
                    } else if (row == 0 && col >= 1) {
                        fogOfWarField[row][col] = spaceFieldTile + colNumber;
                        colNumber++;
                    } else if (row > 0 && col == 0) {
                        fogOfWarField[row][col] = String.valueOf(rowChar);
                        rowChar++;
                    } else {
                        fogOfWarField[row][col] = emptyFieldTile;
                    }
                }
            }
            setFogOfWarField(fogOfWarField);
        }
        public void printFoggyField() {
            System.out.println();
            for (int row = 0; row < fogOfWarField.length; row++) {
                for (int col = 0; col < fogOfWarField[row].length; col++) {
                    System.out.print(fogOfWarField[row][col]);
                }
                System.out.println();
            }
        }
        private void updateFoggyField(boolean shotResult, Game game) {
            if (shotResult) {
                fogOfWarField[game.getShootRow()][game.getShootCol()] = hitTile;
            } else {
                fogOfWarField[game.getShootRow()][game.getShootCol()] = missTile;
            }
        }
        public void shipPlacementPrompt(Game game, CreateField fieldCreation, UserInterface ui) {
            // REMOVED <= 5 from fori, might need?
            for (int ship = 1; ship <= 5; ship++) {
                ShipPlacement shipData = shipToBePlaced(ship);
                String coordinatesPrompt = shipPlacementPrompt(shipData);

                // Printing the prompt for user to enter its ship's coordinates
                ui.headSpace();
                System.out.println(coordinatesPrompt);
                ui.headSpace();

                game.setValiduserInput(false);

                while (!game.isValiduserInput()) {
                    String[] coordinates = UserCoordinatesInput();
                    game.setUserCoordinates(coordinates);
                    game.decodeUserInputCords();

                    userActionValidation.shipPlacementValidation(shipData, game, fieldCreation);

                    // If the user's input is valid, we place the ship on the field
                    if (game.isValiduserInput()) {
                        ui.headSpace();

                        // Mapping the ships coordinates && placing it on the map
                        placeAndMapShip(game, shipData, coordinates);
                        // Mapping the ships coordinates
                        printField();
                    }
                }
            }
        }
        private void placeAndMapShip(Game game, ShipPlacement shipData, String[] coordinates) {
            for (int row = game.getUserRow1(); row <= game.getUserRow2(); row++) {
                for (int col = game.getUserCol1(); col <= game.getUserCol2(); col++) {
                    field[row][col] = shipTile;
                }
            }

            char row1 = coordinates[0].charAt(0);
            int col1 = Integer.parseInt(coordinates[0].substring(1));

            char row2 = coordinates[coordinates.length - 1].charAt(0);
            int col2 = Integer.parseInt(coordinates[coordinates.length - 1].substring(1));

            if (row1 == row2) {
                // Horizontal placement
                int maxCol = Math.max(col1, col2);
                int minCol = Math.min(col1, col2);
                char coordinateChar = row1;
                // Add the start coordinate
                shipData.setShipCoordinates(String.valueOf(coordinateChar) + minCol);

                for (int colAddition = minCol + 1; colAddition <= maxCol; colAddition++) {
                    String coordinate = String.valueOf(coordinateChar) + colAddition;
                    shipData.setShipCoordinates(coordinate);
                }
            } else if (col1 == col2) {
                // Vertical placement
                // Add the start coordinate
                shipData.setShipCoordinates(coordinates[0]);
                int maxRow = Math.max(row1 - 'A', row2 - 'A');
                int minRow = Math.min(row1 - 'A', row2 - 'A');
                int coordinateCol = col1;
                for (int rowAddition = minRow + 1; rowAddition < maxRow; rowAddition++) { // Use < instead of <=
                    char coordinateChar = (char) ('A' + rowAddition);
                    String coordinate = String.valueOf(coordinateChar) + coordinateCol;
                    shipData.setShipCoordinates(coordinate);
                }
                // Add the last coordinate (maxRow, col2) separately
                String coordinate = String.valueOf(row2) + coordinateCol;
                shipData.setShipCoordinates(coordinate);
            }
        }
        public boolean shootShip(Game game) {
            boolean shotResult = false;
            if (field[game.getShootRow()][game.getShootCol()].equals(shipTile)) {
                field[game.getShootRow()][game.getShootCol()] = hitTile;
                shotResult = true;
                updateFoggyField(shotResult, game);
                printFoggyField();
                return true;
            } else if (field[game.getShootRow()][game.getShootCol()].equals(hitTile)) {
                shotResult = true;
                printFoggyField();
                return true;
            } else if (field[game.getShootRow()][game.getShootCol()].equals(missTile)) {
                shotResult = false;
                printFoggyField();
                return true;
            } else {
                field[game.getShootRow()][game.getShootCol()] = missTile;
                shotResult = false;
                updateFoggyField(shotResult, game);
                printFoggyField();
                System.out.println();
                return false;
            }
        }
        private ShipPlacement shipToBePlaced(int ship) {
            // This method is to find out the number of the ship and only then to collect and display data of it
            for (ShipPlacement placement : ShipPlacement.values()) {
                if (placement.getShipNumber() == ship) {
                    return placement;
                }
            }
            return null;
        }
        private String shipPlacementPrompt(ShipPlacement shipData) {
            // Collecting data of the ship based on the value of the fori loop
            // Printing out the prompt for user to input the coordinates of the ship
            String shipName = shipData.getShipName();
            int cellCount = shipData.getCellSize();

            String message = "Enter the coordinates of the " + shipName + " (" + cellCount + " cells):";
            return message;
        }
        private String[] UserCoordinatesInput() {
            Scanner scanner = new Scanner(System.in);
            String coordinateInput = scanner.nextLine();
            return coordinateInput.toUpperCase().split(" ");
        }
    }
  learner_created: true
- name: src/battleship/Game.java
  visible: true
  text: |
    package battleship;

    import java.util.Scanner;

    public class Game {
        private boolean validuserInput = false;
        private String[] userCoordinates;
        private int userRow1 = 0;
        private int userCol1 = 0;
        private int userRow2 = 0;
        private int userCol2 = 0;
        private char shootRowAsChar = 'A';
        private int shootRow = 0;
        private int shootCol = 0;
        private boolean gameWin = false;
        public boolean isValiduserInput() {
            return validuserInput;
        }
        public void setValiduserInput(boolean validuserInput) {
            this.validuserInput = validuserInput;
        }
        public String[] getUserCoordinates() {
            return userCoordinates;
        }
        public void setUserCoordinates(String[] userCoordinates) {
            this.userCoordinates = userCoordinates;
        }
        public int getUserRow1() {
            return userRow1;
        }
        public void setUserRow1(int userRow1) {
            this.userRow1 = userRow1;
        }
        public int getUserCol1() {
            return userCol1;
        }
        public void setUserCol1(int userCol1) {
            this.userCol1 = userCol1;
        }
        public int getUserRow2() {
            return userRow2;
        }
        public void setUserRow2(int userRow2) {
            this.userRow2 = userRow2;
        }
        public int getUserCol2() {
            return userCol2;
        }
        public void setUserCol2(int userCol2) {
            this.userCol2 = userCol2;
        }
        public int getShootRow() {
            return shootRow;
        }
        public void setShootRow(int shootRow) {
            this.shootRow = shootRow;
        }
        public int getShootCol() {
            return shootCol;
        }
        public void setShootCol(int shootCol) {
            this.shootCol = shootCol;
        }
        public boolean isGameWin() {
            return gameWin;
        }
        public void setGameWin(boolean gameWin) {
            this.gameWin = gameWin;
        }
        public char getShootRowAsChar() {
            return shootRowAsChar;
        }
        public void setShootRowAsChar(char shootRowAsChar) {
            this.shootRowAsChar = shootRowAsChar;
        }

        public void prepareTheGame(CreateField fieldCreation, Game game, UserInterface ui) {
            // Creating an empty field
            fieldCreation.createfield();
            fieldCreation.createFogOfWar();

            // Printing an empty field
            fieldCreation.printField();

            // Asking user to input all its ship's
            fieldCreation.shipPlacementPrompt(game, fieldCreation, ui);
        }

        public void playGame(CreateField fieldCreation, UserInterface ui, UserActionValidation uav, Game game) {
            game.setValiduserInput(false);
            // Asking the user for a coordinate to shoot to
            while (!game.isValiduserInput()) {
                userShootCoordinates(ui);
                if (uav.userShootCoordinatesValidation(game)) {
                    game.setValiduserInput(true);
                    boolean shotResult = fieldCreation.shootShip(game);
                    analyzeShot(game);
                    getShipData(ui, shotResult);
                }
            }
        }
        public void decodeUserInputCords() {
            int row1 = (int) getUserCoordinates()[0].charAt(0) - 'A' + 1;
            int col1 = Integer.parseInt(getUserCoordinates()[0].substring(1));

            int row2 = (int) getUserCoordinates()[1].charAt(0) - 'A' + 1;
            int col2 = Integer.parseInt(getUserCoordinates()[1].substring(1));

            // Swap values if necessary so that row1 and col1 are smaller than or equal to row2 and col2
            if (row1 > row2) {
                int temp = row1;
                row1 = row2;
                row2 = temp;
            }

            if (col1 > col2) {
                int temp = col1;
                col1 = col2;
                col2 = temp;
            }

            setUserRow1(row1);
            setUserCol1(col1);
            setUserRow2(row2);
            setUserCol2(col2);
        }
        private void userShootCoordinates(UserInterface ui) {
            Scanner scanner = new Scanner(System.in);

            ui.headSpace();
            String userShootCoordinate = scanner.nextLine();

            // Setting the user's shooting coordinates
            setShootRowAsChar(userShootCoordinate.charAt(0));
            int row = userShootCoordinate.charAt(0) - 'A';
            setShootRow(row + 1);
            setShootCol(Integer.parseInt(userShootCoordinate.substring(1)));
        }
        private void getShipData(UserInterface ui, boolean shotResult) {

            boolean sunkShip = false;
            if (shotResult) {
                for (ShipPlacement ship : ShipPlacement.values()) {
                    if (ship.getHitCount() == ship.getCellSize()) {
                        if (!ship.isSunk()) {
                            ship.setSunk(true);
                            sunkShip = true;
                        }
                    }
                }
            }
            boolean isEnd = isEndGame();
            if (isEnd) {
                ui.endGame();
                setGameWin(true);
            } else if (sunkShip) {
                ui.sankShip();
            } else if (shotResult && !sunkShip) {
                ui.hitShip();
            } else if (!shotResult && !sunkShip) {
                ui.missShip();
            }
        }
        private boolean isEndGame() {
            int countSunkShips = 0;
            for (ShipPlacement ship : ShipPlacement.values()) {
                if (ship.isSunk()) {
                    countSunkShips++;
                }
            }
            if (countSunkShips == 5) {
                return true;
            } else {
                return false;
            }
        }
        private void analyzeShot(Game game) {
            String targetCoordinate = String.valueOf(shootRowAsChar) + shootCol;
            for (ShipPlacement ship : ShipPlacement.values()) {
                if (ship.getShipCoordinates().contains(targetCoordinate)) {
                    ship.setHitCount(ship.getHitCount() + 1);
                }
            }
        }
    }
  learner_created: true
- name: src/battleship/Ships.java
  visible: true
  text: |
    package battleship;

    import java.util.ArrayList;
    import java.util.List;

    public enum ShipPlacement {
        AIRCRAFT_CARRIER ("Aircraft Carrier",1, 5, 0, false, new ArrayList<>()),
        BATTLESHIP("Battleship",2, 4, 0, false, new ArrayList<>()),
        SUBMARINE ("Submarine", 3,3, 0, false, new ArrayList<>()),
        CRUISER ("Cruiser", 4, 3, 0, false, new ArrayList<>()),
        DESTROYER ("Destroyer", 5, 2, 0, false, new ArrayList<>());
        private String shipName;
        private int shipNumber;
        private int cellSize;
        private int hitCount;
        private boolean sunk;
        private List<String> shipCoordinates;
        ShipPlacement(String shipName, int shipNumber, int cellSize, int hitCount, boolean sunk, List<String> shipCoordinates) {
            this.shipName = shipName;
            this.shipNumber = shipNumber;
            this.cellSize = cellSize;
            this.hitCount = hitCount;
            this.sunk = sunk;
            this.shipCoordinates = shipCoordinates;
        }

        public String getShipName() {
            return shipName;
        }
        public int getShipNumber() {
            return shipNumber;
        }
        public int getCellSize() {
            return cellSize;
        }
        public int getHitCount() {
            return hitCount;
        }
        public void setHitCount(int hitCount) {
            this.hitCount = hitCount;
        }
        public boolean isSunk() {
            return sunk;
        }
        public void setSunk(boolean sunk) {
            this.sunk = sunk;
        }
        public List<String> getShipCoordinates() {
            return shipCoordinates;
        }
        public void setShipCoordinates(String data) {
            shipCoordinates.add(data);
        }
    }
  learner_created: true
feedback_link: https://hyperskill.org/learn/step/10598#comment
status: Solved
feedback:
  message: Well done! You've finished the project. Select a new project on <a href="https://hyperskill.org/projects">Hyperskill</a>
    to continue learning.
  time: "Thu, 27 Jul 2023 17:34:07 UTC"
record: -1
